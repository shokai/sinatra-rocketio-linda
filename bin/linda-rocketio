#!/usr/bin/env ruby
$:.unshift File.expand_path '../lib', File.dirname(__FILE__)
require 'rubygems'
require 'sinatra/rocketio/linda/client'
require 'args_parser'

args = ArgsParser.parse ARGV do
  arg :write, 'write Tuple(s)'
  arg :read, 'read a Tuple'
  arg :take, 'take a Tuple'
  arg :watch, 'watch Tuples'
  arg :base, 'linda base URL', :default => 'http://linda.shokai.org'
  arg :space, 'linda space name', :default => 'test'
  arg :timeout, 'wait (sec)', :default => 10
  arg :verbose, 'verbose mode', :alias => :v
  arg :help, 'show help', :alias => :h

  validate :base, "invalid linda URL" do |v|
    v =~ /^https?:\/\/.+/
  end

  [:write, :read, :take, :watch].each do |arg|
    filter arg do |v|
      JSON.parse v
    end
  end
end

class Console
  def self.enable=(bool)
    @@enable = bool
  end

  def self.enable?
    @@enable
  end

  def self.log(str)
    STDOUT.puts "* #{str}" if enable?
  end

  def self.error(str)
    STDERR.puts "! #{str}" if enable?
  end
end

Console.enable = args.has_option? :verbose

if args.has_option? :help or !args.has_param? :base, :space
  bin = $0.split("/").last
  STDERR.puts "RocketIO::Linda v#{Sinatra::RocketIO::Linda::VERSION}"
  STDERR.puts " - https://github.com/shokai/sinatra-rocketio-linda"
  STDERR.puts
  STDERR.puts args.help
  STDERR.puts
  STDERR.puts "e.g."
  STDERR.puts %Q{write   #{bin} --base http://example.com --space test --write '["say","hello"]'}
  STDERR.puts %Q{        echo '["say","hello"]\\n["say","world"]' | #{bin} --base http://example.com --space test --write}
  STDERR.puts %Q{read    #{bin} --base http://example.com --space test --read '["say"]'}
  STDERR.puts %Q{take    #{bin} --base http://example.com --space test --take '["say"]'}
  STDERR.puts %Q{watch   #{bin} --base http://example.com --space test --watch '["say"]'}
  exit 1
end

io = Sinatra::RocketIO::Client.new args[:base]
linda = Sinatra::RocketIO::Linda::Client.new io
ts = linda.tuplespace[ args[:space] ]

linda.io.on :connect do
  Console.log "connect #{io.session} (#{io.type})"
  if args.has_param? :write
    Console.log "write #{args[:write].to_json}"
    ts.write args[:write]
    exit
  elsif args.has_option? :write
    while line = STDIN.gets do
      begin
        tuple = JSON.parse line.strip
        Console.log "write #{tuple.to_json}"
        puts tuple.to_json
        ts.write tuple
      rescue => e
        Console.error e
      end
    end
    exit
  elsif args.has_param? :read
    Console.log "read #{args[:read].to_json}"
    ts.read args[:read] do |tuple|
      puts tuple.to_json
      exit
    end
  elsif args.has_param? :take
    Console.log "take #{args[:take].to_json}"
    ts.take args[:take] do |tuple|
      puts tuple.to_json
      exit
    end
  elsif args.has_param? :watch
    Console.log "watch #{args[:watch].to_json}"
    ts.watch args[:watch] do |tuple|
      puts tuple.to_json
    end
  else
    exit 1
  end
end

linda.io.on :disconnect do
  Console.log "disconnect #{io.session} (#{io.type})"
end

Console.log "waiting #{args[:base]}"
io.connect

if [Fixnum, Float].include? args[:timeout].class and args[:timeout] > 0 and !args.has_option?(:write)
  sleep args[:timeout]
else
  linda.wait
end

Console.log "timeout (#{args[:timeout]}sec)"
