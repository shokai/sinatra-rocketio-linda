#!/usr/bin/env ruby
$:.unshift File.expand_path '../lib', File.dirname(__FILE__)
require 'rubygems'
require 'sinatra/rocketio/linda/client'
require 'args_parser'

args = ArgsParser.parse ARGV do
  arg :write, 'write Tuple(s)'
  arg :read, 'read a Tuple'
  arg :take, 'take a Tuple'
  arg :watch, 'watch Tuples'
  arg :base, 'linda base URL', :default => 'http://linda.shokai.org'
  arg :space, 'linda space name', :default => 'test'
  arg :timeout, 'wait (sec)', :default => 10
  arg :verbose, 'verbose mode', :alias => :v
  arg :help, 'show help', :alias => :h

  validate :base, "invalid linda URL" do |v|
    v =~ /^https?:\/\/.+/
  end

  [:write, :read, :take, :watch].each do |arg|
    filter arg do |v|
      JSON.parse v
    end
  end
end

class Logger
  def enable=(bool)
    @enable = bool
  end

  def enable?
    @enable
  end

  def puts(str)
    STDOUT.puts str if enable?
  end
end

logger = Logger.new
logger.enable = args.has_option? :verbose

if args.has_option? :help or !args.has_param? :base, :space
  STDERR.puts "RocketIO::Linda v#{Sinatra::RocketIO::Linda::VERSION}"
  STDERR.puts " - https://github.com/shokai/sinatra-rocketio-linda"
  STDERR.puts args.help
  exit 1
end

io = Sinatra::RocketIO::Client.new args[:base]
linda = Sinatra::RocketIO::Linda::Client.new io
ts = linda.tuplespace[ args[:space] ]

linda.io.on :connect do
  logger.puts "connect #{io.session} (#{io.type})"
  if args.has_param? :write
    logger.puts "write #{args[:write].to_json}"
    ts.write args[:write]
    exit
  elsif args.has_param? :read
    logger.puts "read #{args[:read].to_json}"
    ts.read args[:read] do |tuple|
      puts tuple.to_json
      exit
    end
  elsif args.has_param? :take
    logger.puts "take #{args[:take].to_json}"
    ts.take args[:take] do |tuple|
      puts tuple.to_json
      exit
    end
  elsif args.has_param? :watch
    logger.puts "watch #{args[:watch].to_json}"
    ts.watch args[:watch] do |tuple|
      puts tuple.to_json
    end
  else
    exit 1
  end
end

linda.io.on :disconnect do
  logger.puts "disconnect #{io.session} (#{io.type})"
end

logger.puts "waiting #{args[:base]}"
io.connect

if [Fixnum, Float].include? args[:timeout].class and args[:timeout] > 0
  sleep args[:timeout]
else
  linda.wait
end

logger.puts "timeout (#{args[:timeout]}sec)"
